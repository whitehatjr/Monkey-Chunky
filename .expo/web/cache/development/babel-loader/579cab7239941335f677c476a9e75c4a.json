{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { Asset } from 'expo-asset';\nimport { Platform } from '@unimodules/core';\nimport ExponentAV from \"./ExponentAV\";\nexport var PitchCorrectionQuality;\n\n(function (PitchCorrectionQuality) {\n  PitchCorrectionQuality[PitchCorrectionQuality[\"Low\"] = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.Low] = \"Low\";\n  PitchCorrectionQuality[PitchCorrectionQuality[\"Medium\"] = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.Medium] = \"Medium\";\n  PitchCorrectionQuality[PitchCorrectionQuality[\"High\"] = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.High] = \"High\";\n})(PitchCorrectionQuality || (PitchCorrectionQuality = {}));\n\nexport var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\nexport var _DEFAULT_INITIAL_PLAYBACK_STATUS = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false\n};\nexport function getNativeSourceFromSource(source) {\n  var uri = null;\n  var overridingExtension = null;\n  var headers;\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension: overridingExtension,\n      headers: headers\n    };\n  }\n\n  var asset = _getAssetFromPlaybackSource(source);\n\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (source != null && typeof source !== 'number' && 'uri' in source && typeof source.uri === 'string') {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (source != null && typeof source !== 'number' && 'overrideFileExtensionAndroid' in source && typeof source.overrideFileExtensionAndroid === 'string') {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (source != null && typeof source !== 'number' && 'headers' in source && typeof source.headers === 'object') {\n    headers = source.headers;\n  }\n\n  return {\n    uri: uri,\n    overridingExtension: overridingExtension,\n    headers: headers\n  };\n}\n\nfunction _getAssetFromPlaybackSource(source) {\n  if (source == null) {\n    return null;\n  }\n\n  var asset = null;\n\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status) {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\nexport function getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst) {\n  var fullInitialStatus, asset, nativeSource;\n  return _regeneratorRuntime.async(function getNativeSourceAndFullInitialStatusForLoadAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          fullInitialStatus = initialStatus == null ? _DEFAULT_INITIAL_PLAYBACK_STATUS : _objectSpread(_objectSpread({}, _DEFAULT_INITIAL_PLAYBACK_STATUS), initialStatus);\n          assertStatusValuesInBounds(fullInitialStatus);\n\n          if (!(typeof source === 'string' && Platform.OS === 'web')) {\n            _context.next = 4;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            nativeSource: {\n              uri: source,\n              overridingExtension: null\n            },\n            fullInitialStatus: fullInitialStatus\n          });\n\n        case 4:\n          asset = _getAssetFromPlaybackSource(source);\n\n          if (!(downloadFirst && asset)) {\n            _context.next = 8;\n            break;\n          }\n\n          _context.next = 8;\n          return _regeneratorRuntime.awrap(asset.downloadAsync());\n\n        case 8:\n          nativeSource = getNativeSourceFromSource(source);\n\n          if (!(nativeSource === null)) {\n            _context.next = 11;\n            break;\n          }\n\n          throw new Error(\"Cannot load an AV asset from a null playback source\");\n\n        case 11:\n          return _context.abrupt(\"return\", {\n            nativeSource: nativeSource,\n            fullInitialStatus: fullInitialStatus\n          });\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getUnloadedStatus() {\n  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return _objectSpread({\n    isLoaded: false\n  }, error ? {\n    error: error\n  } : null);\n}\nexport var PlaybackMixin = {\n  playAsync: function playAsync() {\n    return _regeneratorRuntime.async(function playAsync$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", this.setStatusAsync({\n              shouldPlay: true\n            }));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  playFromPositionAsync: function playFromPositionAsync(positionMillis) {\n    var tolerances,\n        _args3 = arguments;\n    return _regeneratorRuntime.async(function playFromPositionAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            tolerances = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            return _context3.abrupt(\"return\", this.setStatusAsync({\n              positionMillis: positionMillis,\n              shouldPlay: true,\n              seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n              seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n            }));\n\n          case 2:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  pauseAsync: function pauseAsync() {\n    return _regeneratorRuntime.async(function pauseAsync$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", this.setStatusAsync({\n              shouldPlay: false\n            }));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  stopAsync: function stopAsync() {\n    return _regeneratorRuntime.async(function stopAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", this.setStatusAsync({\n              positionMillis: 0,\n              shouldPlay: false\n            }));\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  setPositionAsync: function setPositionAsync(positionMillis) {\n    var tolerances,\n        _args6 = arguments;\n    return _regeneratorRuntime.async(function setPositionAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            tolerances = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n            return _context6.abrupt(\"return\", this.setStatusAsync({\n              positionMillis: positionMillis,\n              seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n              seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n            }));\n\n          case 2:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  setRateAsync: function setRateAsync(rate) {\n    var shouldCorrectPitch,\n        pitchCorrectionQuality,\n        _args7 = arguments;\n    return _regeneratorRuntime.async(function setRateAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            shouldCorrectPitch = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : false;\n            pitchCorrectionQuality = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : PitchCorrectionQuality.Low;\n            return _context7.abrupt(\"return\", this.setStatusAsync({\n              rate: rate,\n              shouldCorrectPitch: shouldCorrectPitch,\n              pitchCorrectionQuality: pitchCorrectionQuality\n            }));\n\n          case 3:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  setVolumeAsync: function setVolumeAsync(volume) {\n    return _regeneratorRuntime.async(function setVolumeAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", this.setStatusAsync({\n              volume: volume\n            }));\n\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  setIsMutedAsync: function setIsMutedAsync(isMuted) {\n    return _regeneratorRuntime.async(function setIsMutedAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", this.setStatusAsync({\n              isMuted: isMuted\n            }));\n\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  setIsLoopingAsync: function setIsLoopingAsync(isLooping) {\n    return _regeneratorRuntime.async(function setIsLoopingAsync$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            return _context10.abrupt(\"return\", this.setStatusAsync({\n              isLooping: isLooping\n            }));\n\n          case 1:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  },\n  setProgressUpdateIntervalAsync: function setProgressUpdateIntervalAsync(progressUpdateIntervalMillis) {\n    return _regeneratorRuntime.async(function setProgressUpdateIntervalAsync$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            return _context11.abrupt(\"return\", this.setStatusAsync({\n              progressUpdateIntervalMillis: progressUpdateIntervalMillis\n            }));\n\n          case 1:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, null, this, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/AV.ts"],"names":[],"mappings":"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","sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from '@unimodules/core';\n\nimport ExponentAV from './ExponentAV';\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\nexport enum PitchCorrectionQuality {\n  Low = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.Low,\n  Medium = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.Medium,\n  High = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.High,\n}\n\nexport type PlaybackSource =\n  | number\n  | {\n      uri: string;\n      overrideFileExtensionAndroid?: string;\n      headers?: { [fieldName: string]: string };\n    }\n  | Asset;\n\nexport type PlaybackNativeSource = {\n  uri: string;\n  overridingExtension?: string | null;\n  headers?: { [fieldName: string]: string };\n};\n\nexport type PlaybackStatus =\n  | {\n      isLoaded: false;\n      androidImplementation?: string;\n      error?: string; // populated exactly once when an error forces the object to unload\n    }\n  | {\n      isLoaded: true;\n      androidImplementation?: string;\n\n      uri: string;\n\n      progressUpdateIntervalMillis: number;\n      durationMillis?: number;\n      positionMillis: number;\n      playableDurationMillis?: number;\n      seekMillisToleranceBefore?: number;\n      seekMillisToleranceAfter?: number;\n\n      shouldPlay: boolean;\n      isPlaying: boolean;\n      isBuffering: boolean;\n\n      rate: number;\n      shouldCorrectPitch: boolean;\n      volume: number;\n      isMuted: boolean;\n      isLooping: boolean;\n\n      didJustFinish: boolean; // true exactly once when the track plays to finish\n    };\n\nexport type PlaybackStatusToSet = {\n  androidImplementation?: string;\n  progressUpdateIntervalMillis?: number;\n  positionMillis?: number;\n  seekMillisToleranceBefore?: number;\n  seekMillisToleranceAfter?: number;\n  shouldPlay?: boolean;\n  rate?: number;\n  shouldCorrectPitch?: boolean;\n  volume?: number;\n  isMuted?: boolean;\n  isLooping?: boolean;\n  pitchCorrectionQuality?: PitchCorrectionQuality;\n};\n\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: PlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  isMuted: false,\n  isLooping: false,\n};\n\nexport function getNativeSourceFromSource(\n  source?: PlaybackSource | null\n): PlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: { [fieldName: string]: string } | undefined;\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  let asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: PlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\nexport function assertStatusValuesInBounds(status: PlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n}\n\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: PlaybackSource | null,\n  initialStatus: PlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: PlaybackNativeSource;\n  fullInitialStatus: PlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: PlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  let asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: PlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\nexport function getUnloadedStatus(error: string | null = null): PlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\nexport interface AV {\n  setStatusAsync(status: PlaybackStatusToSet): Promise<PlaybackStatus>;\n}\n\nexport interface Playback extends AV {\n  playAsync(): Promise<PlaybackStatus>;\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ): Promise<PlaybackStatus>;\n  pauseAsync(): Promise<PlaybackStatus>;\n  stopAsync(): Promise<PlaybackStatus>;\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: { toleranceMillisBefore?: number; toleranceMillisAfter?: number }\n  ): Promise<PlaybackStatus>;\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<PlaybackStatus>;\n  setVolumeAsync(volume: number): Promise<PlaybackStatus>;\n  setIsMutedAsync(isMuted: boolean): Promise<PlaybackStatus>;\n  setIsLoopingAsync(isLooping: boolean): Promise<PlaybackStatus>;\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<PlaybackStatus>;\n}\n\n/**\n * A mixin that defines common playback methods for A/V classes so they implement the `Playback`\n * interface\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: { toleranceMillisBefore?: number; toleranceMillisAfter?: number } = {}\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: { toleranceMillisBefore?: number; toleranceMillisAfter?: number } = {}\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Low\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ volume });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<PlaybackStatus> {\n    return ((this as any) as AV).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}