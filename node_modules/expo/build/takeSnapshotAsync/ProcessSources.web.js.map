{"version":3,"file":"ProcessSources.web.js","sourceRoot":"","sources":["../../src/takeSnapshotAsync/ProcessSources.web.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,SAAS,EACT,qBAAqB,EACrB,gBAAgB,EAChB,UAAU,EACV,uBAAuB,EACvB,eAAe,GAChB,MAAM,aAAa,CAAC;AAErB,MAAM,SAAS,GAAG,6BAA6B,CAAC;AAEhD,MAAM,UAAU,aAAa,CAAC,MAAc;IAC1C,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;QAClB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AACzC,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,2BAA2B,CAC/C,MAAc,EACd,OAAgB,EAChB,GAAI;IAEJ,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE;QAC1B,OAAO,MAAM,CAAC;KACf;IAED,MAAM,IAAI,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;IAE9B,IAAI,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACnC,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;QACtB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,eAAe,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC;KACxE;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,QAAQ,CAAC,IAAY;IAC5B,MAAM,MAAM,GAAe,EAAE,CAAC;IAC9B,IAAI,KAAK,CAAC;IACV,OAAO,CAAC,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI,EAAE;QAC9C,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;KACvB;IACD,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;AAC/C,CAAC;AAID,KAAK,UAAU,eAAe,CAC5B,MAAc,EACd,GAAW,EACX,UAA8B,SAAS,EACvC,iBAAgC,uBAAuB;IAEvD,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IAC1D,MAAM,IAAI,GAAG,MAAM,cAAc,CAAC,QAAQ,CAAC,CAAC;IAC5C,MAAM,OAAO,GAAG,eAAe,CAAC,IAAI,EAAE,qBAAqB,CAAC,GAAG,CAAC,CAAC,CAAC;IAElE,OAAO,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,KAAK,OAAO,IAAI,CAAC,CAAC;AAC3D,CAAC;AAED,SAAS,UAAU,CAAC,GAAG;IACrB,OAAO,IAAI,MAAM,CAAC,iBAAiB,gBAAgB,CAAC,GAAG,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;AAC9E,CAAC","sourcesContent":["import {\n  isDataUrl,\n  getMimeTypeFromSource,\n  getEscapedString,\n  resolveUrl,\n  getSourceAndEncodeAsync,\n  formatDataAsUrl,\n} from './Utils.web';\n\nconst URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\nexport function shouldProcess(string: string): boolean {\n  if (!string.search) {\n    return false;\n  }\n  return string.search(URL_REGEX) !== -1;\n}\n\nexport async function batchProcessAllSourcesAsync(\n  string: string,\n  baseUrl?: string,\n  get?\n): Promise<string> {\n  if (!shouldProcess(string)) {\n    return string;\n  }\n\n  const urls = readURLs(string);\n\n  let done = Promise.resolve(string);\n  for (const url of urls) {\n    done = done.then(string => processURLAsync(string, url, baseUrl, get));\n  }\n  return done;\n}\n\nfunction readURLs(urls: string): Array<any> {\n  const result: Array<any> = [];\n  let match;\n  while ((match = URL_REGEX.exec(urls)) !== null) {\n    result.push(match[1]);\n  }\n  return result.filter(url => !isDataUrl(url));\n}\n\ntype SourceHandler = (value: string) => Promise<string>;\n\nasync function processURLAsync(\n  string: string,\n  url: string,\n  baseUrl: string | undefined = undefined,\n  getSourceAsync: SourceHandler = getSourceAndEncodeAsync\n): Promise<string> {\n  const finalURL = baseUrl ? resolveUrl(url, baseUrl) : url;\n  const data = await getSourceAsync(finalURL);\n  const dataUrl = formatDataAsUrl(data, getMimeTypeFromSource(url));\n\n  return string.replace(URLAsRegex(url), `$1${dataUrl}$3`);\n}\n\nfunction URLAsRegex(url) {\n  return new RegExp(`(url\\\\(['\"]?)(${getEscapedString(url)})(['\"]?\\\\))`, 'g');\n}\n"]}